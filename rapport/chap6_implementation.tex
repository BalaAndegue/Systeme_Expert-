% ============================================================
%  CHAPITRE 6 — IMPLÉMENTATION TECHNIQUE ET OPTIMISATIONS
% ============================================================
\chapter{Implémentation Technique et Optimisations}

\section{Stack Technologique}

\begin{table}[h!]
\centering
\caption{Stack technologique du système}
\begin{tabular}{lll}
\toprule
\rowcolor{AgriBlue!20}
\textbf{Composant} & \textbf{Technologie} & \textbf{Version} \\
\midrule
Langage principal & Python & 3.12 \\
\rowcolor{gray!10}
Framework Web & Flask (async) & 3.0.0 \\
LLM Provider & OpenRouter / Gemini 2.0 Flash & -- \\
\rowcolor{gray!10}
Client LLM & OpenAI SDK (compatible) & 2.8.1 \\
API Météo & Open-Meteo & Gratuite \\
\rowcolor{gray!10}
Tests & pytest + pytest-asyncio & 7.4.3 / 0.21.1 \\
Documentation API & Flasgger (Swagger) & 0.9.5 \\
\rowcolor{gray!10}
Déploiement & Gunicorn + Uvicorn & 21.2.0 / 0.25.0 \\
\bottomrule
\end{tabular}
\end{table}

\section{Optimisations de Performance}

\subsection{Parallélisation des Agents}

La principale optimisation consiste à exécuter les agents sélectionnés \textbf{en parallèle} grâce à \texttt{asyncio.gather()} :

\begin{lstlisting}[language=Python, caption=Parallélisation des agents dans l'orchestrateur]
async def handle_query(self, query: str) -> Dict[str, str]:
    # 1. Routage (1 appel LLM)
    target_agent_names = await self.route_query(query)
    
    # 2. Execution PARALLELE via asyncio.gather
    tasks = [
        self.agents[name].process(query, self.context) 
        for name in target_agent_names
    ]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # 3. Gestion des erreurs gracieuse
    responses = {}
    for name, result in zip(target_agent_names, results):
        if isinstance(result, Exception):
            responses[name] = f"Agent {name} indisponible."
        else:
            responses[name] = result
    
    return responses
\end{lstlisting}

\subsection{Fusion Intent + Extraction}

Chaque agent effectuait initialement \textbf{2 appels LLM séquentiels} (classification d'intent + extraction d'entités). L'optimisation fusionne ces deux appels en un seul prompt JSON :

\begin{lstlisting}[language=Python, caption=Prompt combiné intent+extraction (get\_combined\_prompt)]
def get_combined_prompt(query: str, region: str) -> str:
    return f"""Analyse cette requete d'agriculteur camerounais.

Requete: "{query}"
Region: {region}

Retourne UNIQUEMENT ce JSON (sans markdown):
{{
  "intent": "<CALENDAR|ROTATION|VARIETY|TECHNIQUE|GENERAL>",
  "culture": "<nom culture ou Non specifie>"
}}"""
\end{lstlisting}

\subsection{Bilan des Optimisations}

\begin{figure}[h!]
\centering
\begin{tikzpicture}
\begin{axis}[
  ybar,
  bar width=0.6cm,
  width=12cm, height=7cm,
  xlabel={Requête},
  ylabel={Latence (secondes)},
  xtick=data,
  xticklabels={Cultures Centre, Diagnostic Cacao, Engrais Maïs, Moyenne},
  legend style={at={(0.5,1.05)}, anchor=south, legend columns=2},
  ymin=0, ymax=50,
  nodes near coords,
  nodes near coords align={vertical},
  every node near coord/.style={font=\small},
  grid=major,
  grid style={dashed, gray!30},
]
\addplot[fill=AgriRed!70, draw=AgriRed] 
  coordinates {(1,21.1) (2,40.5) (3,21.5) (4,27.7)};
\addplot[fill=AgriGreen!70, draw=AgriGreen] 
  coordinates {(1,19.4) (2,29.5) (3,19.4) (4,22.7)};
\legend{Avant optimisation, Après optimisation}
\end{axis}
\end{tikzpicture}
\caption{Comparaison des latences avant et après optimisations}
\label{fig:latence_comparaison}
\end{figure}

\begin{table}[h!]
\centering
\caption{Récapitulatif des gains de performance}
\begin{tabular}{lccc}
\toprule
\rowcolor{AgriBlue!20}
\textbf{Requête} & \textbf{Avant} & \textbf{Après} & \textbf{Gain} \\
\midrule
Cultures région Centre & 21.1s & 19.4s & \textcolor{AgriGreen}{-8\%} \\
\rowcolor{gray!10}
Diagnostic maladie cacao & 40.5s & 29.5s & \textcolor{AgriGreen}{\textbf{-27\%}} \\
Engrais pour maïs & 21.5s & 19.4s & \textcolor{AgriGreen}{-10\%} \\
\rowcolor{gray!10}
\textbf{Moyenne} & \textbf{27.7s} & \textbf{22.7s} & \textcolor{AgriGreen}{\textbf{-18\%}} \\
\bottomrule
\end{tabular}
\end{table}

\section{API REST}

\subsection{Endpoints Disponibles}

\begin{table}[h!]
\centering
\caption{Endpoints de l'API REST}
\begin{tabularx}{\textwidth}{llX}
\toprule
\rowcolor{AgriBlue!20}
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} \\
\midrule
POST & \texttt{/api/query} & Requête principale au système expert \\
\rowcolor{gray!10}
GET & \texttt{/api/regions} & Liste des 10 régions et leurs caractéristiques \\
GET & \texttt{/api/health} & Statut du système \\
\rowcolor{gray!10}
POST & \texttt{/api/predict-crop} & Prédiction ML de la culture adaptée \\
GET & \texttt{/api/weather/\{region\}} & Données météo temps réel \\
\rowcolor{gray!10}
GET & \texttt{/apidocs} & Documentation Swagger interactive \\
\bottomrule
\end{tabularx}
\end{table}

\subsection{Exemple d'Appel API}

\begin{lstlisting}[language=bash, caption=Exemple d'appel API REST]
# Requete au systeme expert
curl -X POST http://localhost:5000/api/query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "Mes feuilles de cacao ont des taches brunes",
    "region": "Centre",
    "parcelle_id": "CM-CENTRE-0042"
  }'

# Reponse (exemple)
{
  "status": "success",
  "agents_consultes": ["HealthAgent", "CropAgent"],
  "latence_ms": 18500,
  "reponse": "Diagnostic: Pourriture brune (Phytophthora palmivora)..."
}
\end{lstlisting}

\section{Gestion des Tests}

\subsection{Suite de Tests}

Le projet dispose de \textbf{17 tests automatisés} couvrant tous les composants :

\begin{lstlisting}[language=bash, caption=Lancement de la suite de tests]
# Configuration pytest (pytest.ini)
[pytest]
asyncio_mode = auto

# Lancement des tests
python -m pytest tests/ -v

# Resultat : 17 passed in 159.27s
\end{lstlisting}

\begin{table}[h!]
\centering
\caption{Couverture des tests par module}
\begin{tabular}{lcc}
\toprule
\rowcolor{AgriBlue!20}
\textbf{Fichier de test} & \textbf{Tests} & \textbf{Résultat} \\
\midrule
\texttt{test\_basics.py} & 5 & \textcolor{AgriGreen}{\textbf{PASS}} \\
\rowcolor{gray!10}
\texttt{test\_fertilizer\_agent.py} & 2 & \textcolor{AgriGreen}{\textbf{PASS}} \\
\texttt{test\_weather\_api.py} & 4 & \textcolor{AgriGreen}{\textbf{PASS}} \\
\rowcolor{gray!10}
\texttt{test\_weather\_tools\_v2.py} & 4 & \textcolor{AgriGreen}{\textbf{PASS}} \\
\texttt{test\_economic\_agent.py} & 1 & \textcolor{AgriGreen}{\textbf{PASS}} \\
\rowcolor{gray!10}
\texttt{test\_health\_agent.py} & 1 & \textcolor{AgriGreen}{\textbf{PASS}} \\
\midrule
\textbf{Total} & \textbf{17} & \textcolor{AgriGreen}{\textbf{17/17 PASS}} \\
\bottomrule
\end{tabular}
\end{table}
